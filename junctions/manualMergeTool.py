
# External imports

import fire

import pandas as pd

import numpy as np

from itertools import starmap

from shapely.geometry.polygon import Polygon 

# Internal imports

# (1) Manual cluster preparation tool:
#     Provides the data required for manual cluster correction.
#     This data indicates where clustering solutions differ between buffers, i.e. where merges have
#     taken place when utilizing a rather liberal buffer parameter (e.g., 3) but not when utilizing a 
#     more conservative one (e.g., 2).
#     2 and 3 as conservative resp. liberal buffer parameter will work in most cases; consider increasing
#     resp. decreasing them by 0.5 each for particularly narrow resp. wide city layouts.
#     
#     In this script, we do not only use the data generated by manualClusterPrep but also call one of its
#     functions directly:
#     * plotPrep: polygon shapes of junctions in the same cluster are dissolved, i.e. melted together;
#                 the remaining columns are also aggregated by cluster. (Naturally, these operations
#                 are only performed for the 'non-isolated junctions', i.e. those whose polygon surfaces
#                 overlap with those of other junctions) 

import manualClusterPrep

# (2) Mapping tool as helper for manual cluster correction:
#     Differs from the standard mapping tool used by the main script (OSM_Jcts) with respect to the following aspects:
#     - inconsistent clusters (where merges have taken place with a liberal, but not a conservative buffer)
#       are highlighted in yellow.
#     - markers are attached to polygons; upon click, the respective cluster-nr. is displayed. This way,
#       a manual merge can be performed via CLI by specifying the to-be-merged cluster nrs.

import mapJcts_clustAssist as mapping

# (3) Data tidying tool for junctions:
#     This is the exact same script used by the main script (OSM_Jcts). Here, it helps with
#     - dealing with multi-polygons which may have emerged during cluster merges
#     - aligning the columns in the data frame containing non-isolated junctions (which have been clustered and merged
#       together) and isolated junctions (whose polygon surfaces don't overlap with those of any other junctions
#       and which hence have not been merged with any other junctions),
#     - and finally merging the two dfs together. 

import tidyData_Jcts

# ---------------------------------------------------------------------------------------------------

# (*) This function is called by update_clust (the function exposed as CLI) after clusters have been
#     re-assigned. 
#     The df is split into the rows that will be merged as specified by CLI params and the remainder
#     of the df. 
#     Then, geometric shape dissolving and data aggregation (taken together, these operations 
#     constitute the merging procedure) is performed on the to-be-merged rows (those with cluster = new_clust,
#     with new_clust having been their assigned cluster all along OR having been specified as their updated
#     cluster per user input via CLI)

def reMerge(complete_df, new_clust):

    target = complete_df[complete_df["neighbour_cluster"] == new_clust] 

    # Grab the rows from complete_df that are NOT going to be merged

    remainder = complete_df[complete_df["neighbour_cluster"] != new_clust]

    # Melt target rows together

    melted_target = manualClusterPrep.plotPrep(target)

    return melted_target, remainder

# Expose functionality as CLI using fire library

# ($) Function for changing a junction's cluster manually via command line.

# Sample call of CLI: python manualMergeTool.py --curr-clust=600.0 --new_clust=605.0 --region="pforz" --buffer_size=2

# USAGE:
# (a) Execute manualClusterPrep, specifying the region and the buffers of different sizes to compare.
# (b) Open the map generated by manualClusterPrep: {region}-jcts-manualClust_buf={bufferSize}_np={neighbourParam}.html
# (c) Examine which of the inconsistent clusters you want to merge (click on marker reveals the respective neighbour clusters).
# (d) Call update_clust according to the sample call above, putting in as parameters the clusters to merge, the region
#     and the size of the smaller buffer.
# (e) Reload the map (refresh browser window) to see the result.

def update_clust(curr_clust, new_clust, region, buffer_size):

    complete_df = pd.read_pickle("manualMergeTarget")

    complete_df.loc[:,'neighbour_cluster'] = complete_df['neighbour_cluster'].map(lambda x: x if x != curr_clust else new_clust)

    target, remainder = reMerge(complete_df, new_clust)

    mapping.runAllMapTasks(region, target, remainder, buffer_size)

    complete_df = tidyData_Jcts.explodeAndConcat(target, remainder)

    complete_df.to_pickle("manualMergeTarget")

    complete_df.to_csv('manual_merging_res.csv', index=False, sep="|")

if __name__ == '__main__':
  fire.Fire(update_clust)


